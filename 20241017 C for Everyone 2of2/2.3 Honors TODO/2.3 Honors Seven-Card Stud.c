not finished
/*TASK:
Link for the TASK and probability table:
https://www.coursera.org/learn/c-structured-programming/peer/oksx9/week-2-honors-assignment/submit

Use a struct to define a card as an enumerated member that is its suit value and a short that is its pips value.

Write a function that randomly shuffles the deck.

Submit your work as a text file.

Then deal out 7 card hands and evaluate the probability that a hand has no pair, 
one pair, two pair, three of a kind, full house and 4 of a kind.  
This is a Monte Carlo method to get an approximation to these probabilities.  
Use at least 1 million randomly generated hands.

You can check against probabilities found in a standard table. 


Hand                Combinations                Probabilities

Royal flush         4324                        0.00003232

Straight flush      37260                       0.00027851

Four of a kind      224848                      0.00168067

Full house          3473184                     0.02596102

Flush               4047644                     0.03025494

Straight            6180020                     0.04619382

Three of a kind     6461620                     0.04829870

Two pair            31433400                    0.23495536

Pair                58627800                    0.43822546

Ace high or less    23294460                    0.17411920

Total               133784560                   1.00000000
*/

/* definitions
Royal Flush:
Definition: The highest possible hand in poker, consisting of the ace, king, queen, jack, and ten, all of the same suit.


Straight Flush:
Definition: Five consecutive cards of the same suit.


Four of a Kind (Quads):
Definition: Four cards of the same rank and one side card or 'kicker'.


Full House:
Definition: Three cards of one rank and two cards of another rank.


Flush:
Definition: Five cards of the same suit, not in sequence.


Straight:
Definition: Five consecutive cards of different suits.


Three of a Kind (Trips):
Definition: Three cards of the same rank and two unrelated side cards.


Two Pair:
Definition: Two cards of one rank, two cards of another rank, and one side card.


Pair:
Definition: Two cards of the same rank and three unrelated side cards.


High Card:
Definition: When no other hand combination can be made, the highest card plays.

*/
#include <stdio.h>
#include <stdlib.h>

typedef enum suits { Hearts, Diamonds, Clubs, Spades} suits;

typedef enum pips { Ace = 1, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King} pips;

// the task is to use short int for pips. I use it inside the enum starting from Ace = 1
typedef struct card { suits suit; pips pip; } card;

// taking a random card from a deck (remaining deck)
card random_card()
{
    card new_card; // taking the card
    new_card.suit = rand() % 4; // looking at its suit
    new_card.pip = (rand() % 13) + 1; // looking at its pip
    return new_card;
}

// do we have Royal Flush? in a suit? returns 1 if yes.
int royal_flush_in_suit(const* suit)
{
    if (suit[1] && suit[11] && suit[12] && suit[13] && suit[14]) return 1;
    else return 0;
}


// do we have Royal Flush? returns 1 if yes.
int royal_flush(const card* card7hands)
{
    /*Algorithm Steps:
1) Initialize Counters: Create counters for each suit to track the occurrence of each pip (rank) within the suits.

2) Iterate Over Cards: Traverse through the 7-card hand and update the counters for the corresponding suit and pip.

3) Check for Royal Flush: After counting, check each suit to see if it contains all the necessary pips for a Royal Flush.*/

//Initialize an array to count pips for each suit:
    // the array size is 14 for convenience. 0th item will not be used.
    // 14 to cover pips from 1 to 13
int hearts[14] = { 0 };  
int diamonds[14] = { 0 };
int clubs[14] = { 0 };
int spades[14] = { 0 };

//Iterate over each card in the hand to update the counters:
for (int i = 0; i < 7; i++) // cheking all 7 cards one by one 
{ 
    card currentCard = card7hands[i]; 
    switch (currentCard.suit) {
    case Hearts:
        hearts[currentCard.pip]++; //for example in case the card is Hearts 10,
            //the hearts[10th] element will be incremented by 1 
        break;
    case Diamonds:
        diamonds[currentCard.pip]++;
        break;
    case Clubs:
        clubs[currentCard.pip]++;
        break;
    case Spades:
        spades[currentCard.pip]++;
        break;
    }
} // for

if (royal_flush_in_suit(&hearts) ||
    royal_flush_in_suit(&diamonds) ||
    royal_flush_in_suit(&clubs) ||
    royal_flush_in_suit(&spades))
    return 1;

else return 0;
}


// checking for combination generated by deal_out() function receiving 'card7hands' array from there
// returns combinaiton number from 1 to 10
int combitation(const card* card7hands)
{
     
    
    if (royal_flush(&card7hands)) return 1;// 1 for Royal Flush:
    //2 for Straight Flush
    //3 for 
    //4 for 
    //5 for 
    //6 for 
    //7 for 
    //8 for 
    //9 for 
    //10 for 
    
    return 0; //for any other outcome;
}




// dealing out function. Will return a combination
int deal_out()
{
    card card7hands[7]; // our 7 cards will be stored here
    
    card card1 = random_card();
    card7hands[0] = card1;
    

    card card2 = random_card();
    while ((card2.suit == card1.suit) && (card2.pip == card1.pip))
    {
        card2 = random_card(); // avoiding taking already taken card, which is impossible in a real world
    }
    card7hands[1] = card2;


    card card3 = random_card();
    while ( ((card3.suit == card1.suit) && (card3.pip == card1.pip)) ||
            ((card3.suit == card2.suit) && (card3.pip == card2.pip))  )
    {
        card3 = random_card(); // avoiding taking already taken card, which is impossible in a real world
    }
    card7hands[2] = card3;


    card card4 = random_card();
    while ( ((card4.suit == card1.suit) && (card4.pip == card1.pip)) ||
            ((card4.suit == card2.suit) && (card4.pip == card2.pip)) ||
            ((card4.suit == card3.suit) && (card4.pip == card3.pip))  )
    {
        card4 = random_card(); // avoiding taking already taken card, which is impossible in a real world
    }
    card7hands[3] = card4;


    card card5 = random_card();
    while ( ((card5.suit == card1.suit) && (card5.pip == card1.pip)) ||
            ((card5.suit == card2.suit) && (card5.pip == card2.pip)) ||
            ((card5.suit == card3.suit) && (card5.pip == card3.pip)) ||
            ((card5.suit == card4.suit) && (card5.pip == card4.pip)) )
    {
        card5 = random_card(); // avoiding taking already taken card, which is impossible in a real world
    }
    card7hands[4] = card5;


    card card6 = random_card();
    while ( ((card6.suit == card1.suit) && (card6.pip == card1.pip)) ||
            ((card6.suit == card2.suit) && (card6.pip == card2.pip)) ||
            ((card6.suit == card3.suit) && (card6.pip == card3.pip)) ||
            ((card6.suit == card4.suit) && (card6.pip == card4.pip)) ||
            ((card6.suit == card5.suit) && (card6.pip == card5.pip)) )
    {
        card6 = random_card(); // avoiding taking already taken card, which is impossible in a real world
    }
    card7hands[5] = card6;


    card card7 = random_card();
    while ( ((card7.suit == card1.suit) && (card7.pip == card1.pip)) ||
            ((card7.suit == card2.suit) && (card7.pip == card2.pip)) ||
            ((card7.suit == card3.suit) && (card7.pip == card3.pip)) ||
            ((card7.suit == card4.suit) && (card7.pip == card4.pip)) ||
            ((card7.suit == card5.suit) && (card7.pip == card5.pip)) ||
            ((card7.suit == card6.suit) && (card7.pip == card6.pip)) )

    {
        card7 = random_card(); // avoiding taking already taken card, which is impossible in a real world
    }
    card7hands[6] = card7;
    return combitation(&card7hands); // returns combinaiton number from 1 to 10
}

int main()
{
    srand(time(NULL)); // seeding the random function with unique number

    //int number_of_deals = 3; 
    int number_of_deals = 100000;
    //int number_of_deals = 10000000; //10M comninations didn't return any Royal Flash 
    
    
    
    //int number_of_deals = 133784560;
    int i = 0;
    
    int number_of_Royal_flush = 0;
    int number_of_Straight_flush = 0;
    int number_of_Four_of_a_kind = 0;
    int number_of_Full_house = 0;
    int number_of_Flush = 0;
    int number_of_Straight = 0;
    int number_of_Three_of_a_kind = 0;
    int number_of_Two_pair = 0;
    int number_of_Pair = 0;
    int number_of_Ace_high_or_less = 0;
    for (i = 0; i < number_of_deals; i++)
    {
        switch (deal_out())
        {
        case 1:
        {
            number_of_Royal_flush++; 
            //printf("Royal Flush!\n");
            break;
        }
        case 10:
        default:
        {
            number_of_Ace_high_or_less++;
            //printf("No combination!\n");
            break;
        }
        }
    }
    printf("number of Royal Flush: %d \n", number_of_Royal_flush);
    printf("number of High Card: %d \n", number_of_Ace_high_or_less);
    //deal_out();
    //printf("hellow C world!");
}